{"version":3,"sources":["file:///E:/sxbs2/sxbs2/assets/script/core/utils/ViewUtil.ts"],"names":["ViewUtil","Animation","AnimationClip","instantiate","Prefab","Size","UITransform","v3","resLoader","nodeTreeInfoLite","parent","obj","map","Map","items","children","i","length","_node","name","indexOf","set","findNodes","reg","nodes","ns","_name","test","push","calculateASpaceToBSpacePos","a","b","aPos","world","getComponent","convertToWorldSpaceAR","convertToNodeSpaceAR","calculateScreenPosToSpacePos","event","space","uil","getUILocation","worldPos","x","y","uniformScale","targetWidth","targetHeight","defaultWidth","defaultHeight","widthRatio","heightRatio","ratio","Math","floor","createPrefabNode","path","bundleName","defaultBundleName","p","get","createPrefabNodeAsync","Promise","resolve","reject","loadAsync","console","error","addNodeAnimation","node","onlyOne","isDefaultClip","isValid","anim","addComponent","clip","getState","isPlaying","defaultClip","play","once","EventType","FINISHED","createState"],"mappings":"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","sourcesContent":["//cpall\r\nimport { Animation, AnimationClip, EventTouch, instantiate, Node, Prefab, Size, UITransform, v3, Vec3 } from \"cc\";\r\nimport { resLoader } from \"../common/loader/ResLoader\";\r\n\r\n/** 显示对象工具 */\r\nexport class ViewUtil {\r\n    /**\r\n     * 把Node当前的节点树结构根据Node命名转成一个js对象,重名的组件会覆盖，\r\n     * Node的name不应该包含空格键，否则将跳过\r\n     * @param parent 被遍历的Node组件\r\n     * @param obj    绑定的js对象 (可选)\r\n     */\r\n    static nodeTreeInfoLite(parent: Node, obj?: Map<string, Node>): Map<string, Node> | null {\r\n        let map: Map<string, Node> = obj || new Map();\r\n        let items = parent.children;\r\n        for (let i = 0; i < items.length; i++) {\r\n            let _node = items[i];\r\n            if (_node.name.indexOf(\" \") < 0) {\r\n                map.set(_node.name, _node);\r\n            }\r\n            ViewUtil.nodeTreeInfoLite(_node, map);\r\n        }\r\n        return map;\r\n    }\r\n\r\n    /**\r\n     * 正则搜索节点名字,符合条件的节点将会返回\r\n     * @param reg     正则表达式\r\n     * @param parent  要搜索的父节点\r\n     * @param nodes   返回的数组（可选）\r\n     */\r\n    static findNodes(reg: RegExp, parent: Node, nodes?: Array<Node>): Array<Node> {\r\n        let ns: Array<Node> = nodes || [];\r\n        let items = parent.children;\r\n        for (let i = 0; i < items.length; i++) {\r\n            let _name: string = items[i].name;\r\n            if (reg.test(_name)) {\r\n                ns.push(items[i]);\r\n            }\r\n            ViewUtil.findNodes(reg, items[i], ns);\r\n        }\r\n        return ns;\r\n    };\r\n\r\n    /**\r\n     * 节点之间坐标互转\r\n     * @param a         A节点\r\n     * @param b         B节点\r\n     * @param aPos      A节点空间中的相对位置\r\n     */\r\n    static calculateASpaceToBSpacePos(a: Node, b: Node, aPos: Vec3): Vec3 {\r\n        const world: Vec3 = a.getComponent(UITransform)!.convertToWorldSpaceAR(aPos);\r\n        return b.getComponent(UITransform)!.convertToNodeSpaceAR(world);\r\n    }\r\n\r\n    /**\r\n     * 屏幕转空间坐标\r\n     * @param event 触摸事件\r\n     * @param space 转到此节点的坐标空间\r\n     */\r\n    static calculateScreenPosToSpacePos(event: EventTouch, space: Node): Vec3 {\r\n        const uil = event.getUILocation();\r\n        const worldPos: Vec3 = v3(uil.x, uil.y);\r\n        return space.getComponent(UITransform)!.convertToNodeSpaceAR(worldPos);\r\n    }\r\n\r\n    /**\r\n     * 显示对象等比缩放\r\n     * @param targetWidth       目标宽\r\n     * @param targetHeight      目标高\r\n     * @param defaultWidth      默认宽\r\n     * @param defaultHeight     默认高\r\n     */\r\n    static uniformScale(targetWidth: number, targetHeight: number, defaultWidth: number, defaultHeight: number) {\r\n        const widthRatio = defaultWidth / targetWidth;\r\n        const heightRatio = defaultHeight / targetHeight;\r\n        let ratio;\r\n        widthRatio < heightRatio ? ratio = widthRatio : ratio = heightRatio;\r\n        return new Size(Math.floor(targetWidth * ratio), Math.floor(targetHeight * ratio));\r\n    }\r\n\r\n    /**\r\n     * 从资源缓存中找到预制资源名并创建一个显示对象（建议使用GameComponent里的同名方法，能自动管理内存施放）\r\n     * @param path        资源路径\r\n     * @param bundleName  资源包名\r\n     */\r\n    static createPrefabNode(path: string, bundleName: string = resLoader.defaultBundleName): Node {\r\n        const p = resLoader.get(path, Prefab, bundleName);\r\n        if (p) {\r\n            return instantiate(p);\r\n        }\r\n        return null!;\r\n    }\r\n\r\n    /**\r\n     * 加载预制并创建预制节点（建议使用GameComponent里的同名方法，能自动管理内存施放）\r\n     * @param path        资源路径\r\n     * @param bundleName  资源包名\r\n     */\r\n    static createPrefabNodeAsync(path: string, bundleName: string = resLoader.defaultBundleName): Promise<Node> {\r\n        return new Promise(async (resolve, reject) => {\r\n            const p = await resLoader.loadAsync(bundleName, path, Prefab);\r\n            if (p) {\r\n                resolve(instantiate(p));\r\n            }\r\n            else {\r\n                console.error(`名为【${path}】的资源加载失败`);\r\n                resolve(null!);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 添加节点动画\r\n     * @param path              资源路径\r\n     * @param node              目标节点\r\n     * @param onlyOne           是否唯一\r\n     * @param isDefaultClip     是否播放默认动画剪辑\r\n     */\r\n    static addNodeAnimation(path: string, node: Node, onlyOne: boolean = true, isDefaultClip: boolean = false) {\r\n        if (!node || !node.isValid) {\r\n            return;\r\n        }\r\n\r\n        let anim = node.getComponent(Animation);\r\n        if (anim == null) {\r\n            anim = node.addComponent(Animation);\r\n        }\r\n\r\n        const clip = resLoader.get(path, AnimationClip) as AnimationClip;\r\n        if (!clip) {\r\n            return;\r\n        }\r\n\r\n        if (onlyOne && anim.getState(clip.name) && anim.getState(clip.name).isPlaying) {\r\n            return;\r\n        }\r\n\r\n        if (isDefaultClip) {\r\n            anim.defaultClip = clip;\r\n            anim.play();\r\n            return;\r\n        }\r\n\r\n        // 播放完成后恢复播放默认动画\r\n        anim.once(Animation.EventType.FINISHED, () => {\r\n            if (anim!.defaultClip) {\r\n                anim!.play();\r\n            }\r\n        }, this);\r\n\r\n        if (anim.getState(clip.name)) {\r\n            anim.play(clip.name);\r\n            return\r\n        }\r\n        anim.createState(clip, clip!.name);\r\n        anim.play(clip!.name);\r\n    }\r\n}"]}